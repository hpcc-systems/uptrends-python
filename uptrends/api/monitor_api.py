# coding: utf-8

"""
    Uptrends API v4

    This document describes Uptrends API version 4. This Swagger environment also lets you execute API methods directly.  Please note that this is not a sandbox environment: these API methods operate directly on your actual Uptrends account.  For more information, please visit https://www.uptrends.com/api.  # noqa: E501

    OpenAPI spec version: 1.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from uptrends.api_client import ApiClient


class MonitorApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def monitor_cleanup_maintenance_periods(self, monitor_guid, before_date, **kwargs):  # noqa: E501
        """Clears out all one-time maintenance periods for the specified monitor older than the specified date  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.monitor_cleanup_maintenance_periods(monitor_guid, before_date, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str monitor_guid: (required)
        :param datetime before_date: A string representing the date, formatted as \"yyyy-MM-dd\" (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.monitor_cleanup_maintenance_periods_with_http_info(monitor_guid, before_date, **kwargs)  # noqa: E501
        else:
            (data) = self.monitor_cleanup_maintenance_periods_with_http_info(monitor_guid, before_date, **kwargs)  # noqa: E501
            return data

    def monitor_cleanup_maintenance_periods_with_http_info(self, monitor_guid, before_date, **kwargs):  # noqa: E501
        """Clears out all one-time maintenance periods for the specified monitor older than the specified date  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.monitor_cleanup_maintenance_periods_with_http_info(monitor_guid, before_date, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str monitor_guid: (required)
        :param datetime before_date: A string representing the date, formatted as \"yyyy-MM-dd\" (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['monitor_guid', 'before_date']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method monitor_cleanup_maintenance_periods" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'monitor_guid' is set
        if ('monitor_guid' not in params or
                params['monitor_guid'] is None):
            raise ValueError("Missing the required parameter `monitor_guid` when calling `monitor_cleanup_maintenance_periods`")  # noqa: E501
        # verify the required parameter 'before_date' is set
        if ('before_date' not in params or
                params['before_date'] is None):
            raise ValueError("Missing the required parameter `before_date` when calling `monitor_cleanup_maintenance_periods`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'monitor_guid' in params:
            path_params['monitorGuid'] = params['monitor_guid']  # noqa: E501
        if 'before_date' in params:
            path_params['beforeDate'] = params['before_date']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicauth']  # noqa: E501

        return self.api_client.call_api(
            '/Monitor/{monitorGuid}/MaintenancePeriod/Cleanup/{beforeDate}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def monitor_clone_monitor(self, monitor_guid, **kwargs):  # noqa: E501
        """Creates a clone (duplicate) of the specified monitor.  # noqa: E501

        Upon creation, the new monitor will be inactive. This allows you to make the necessary changes before you activate it. All other settings will be transferred to the new monitor as-is.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.monitor_clone_monitor(monitor_guid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str monitor_guid: The guid of the monitor you want to clone. (required)
        :param bool include_maintenance_periods: Whether or not to also copy the maintenance periods into the clone.
        :param bool include_monitor_groups: Whether or not to also copy the monitor group memberships into the clone.
        :return: Monitor
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.monitor_clone_monitor_with_http_info(monitor_guid, **kwargs)  # noqa: E501
        else:
            (data) = self.monitor_clone_monitor_with_http_info(monitor_guid, **kwargs)  # noqa: E501
            return data

    def monitor_clone_monitor_with_http_info(self, monitor_guid, **kwargs):  # noqa: E501
        """Creates a clone (duplicate) of the specified monitor.  # noqa: E501

        Upon creation, the new monitor will be inactive. This allows you to make the necessary changes before you activate it. All other settings will be transferred to the new monitor as-is.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.monitor_clone_monitor_with_http_info(monitor_guid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str monitor_guid: The guid of the monitor you want to clone. (required)
        :param bool include_maintenance_periods: Whether or not to also copy the maintenance periods into the clone.
        :param bool include_monitor_groups: Whether or not to also copy the monitor group memberships into the clone.
        :return: Monitor
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['monitor_guid', 'include_maintenance_periods', 'include_monitor_groups']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method monitor_clone_monitor" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'monitor_guid' is set
        if ('monitor_guid' not in params or
                params['monitor_guid'] is None):
            raise ValueError("Missing the required parameter `monitor_guid` when calling `monitor_clone_monitor`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'monitor_guid' in params:
            path_params['monitorGuid'] = params['monitor_guid']  # noqa: E501

        query_params = []
        if 'include_maintenance_periods' in params:
            query_params.append(('includeMaintenancePeriods', params['include_maintenance_periods']))  # noqa: E501
        if 'include_monitor_groups' in params:
            query_params.append(('includeMonitorGroups', params['include_monitor_groups']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicauth']  # noqa: E501

        return self.api_client.call_api(
            '/Monitor/{monitorGuid}/Clone', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Monitor',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def monitor_create_maintenance_period_for_monitor(self, maintenance_period, monitor_guid, **kwargs):  # noqa: E501
        """Saves the new maintenance period provided for the specified monitor  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.monitor_create_maintenance_period_for_monitor(maintenance_period, monitor_guid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param MaintenancePeriod maintenance_period: (required)
        :param str monitor_guid: (required)
        :return: MaintenancePeriod
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.monitor_create_maintenance_period_for_monitor_with_http_info(maintenance_period, monitor_guid, **kwargs)  # noqa: E501
        else:
            (data) = self.monitor_create_maintenance_period_for_monitor_with_http_info(maintenance_period, monitor_guid, **kwargs)  # noqa: E501
            return data

    def monitor_create_maintenance_period_for_monitor_with_http_info(self, maintenance_period, monitor_guid, **kwargs):  # noqa: E501
        """Saves the new maintenance period provided for the specified monitor  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.monitor_create_maintenance_period_for_monitor_with_http_info(maintenance_period, monitor_guid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param MaintenancePeriod maintenance_period: (required)
        :param str monitor_guid: (required)
        :return: MaintenancePeriod
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['maintenance_period', 'monitor_guid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method monitor_create_maintenance_period_for_monitor" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'maintenance_period' is set
        if ('maintenance_period' not in params or
                params['maintenance_period'] is None):
            raise ValueError("Missing the required parameter `maintenance_period` when calling `monitor_create_maintenance_period_for_monitor`")  # noqa: E501
        # verify the required parameter 'monitor_guid' is set
        if ('monitor_guid' not in params or
                params['monitor_guid'] is None):
            raise ValueError("Missing the required parameter `monitor_guid` when calling `monitor_create_maintenance_period_for_monitor`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'monitor_guid' in params:
            path_params['monitorGuid'] = params['monitor_guid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'maintenance_period' in params:
            body_params = params['maintenance_period']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicauth']  # noqa: E501

        return self.api_client.call_api(
            '/Monitor/{monitorGuid}/MaintenancePeriod', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MaintenancePeriod',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def monitor_delete_maintenance_period_from_monitor(self, monitor_guid, maintenance_period_id, **kwargs):  # noqa: E501
        """Deletes the specified maintenance period from the specified monitor  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.monitor_delete_maintenance_period_from_monitor(monitor_guid, maintenance_period_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str monitor_guid: (required)
        :param int maintenance_period_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.monitor_delete_maintenance_period_from_monitor_with_http_info(monitor_guid, maintenance_period_id, **kwargs)  # noqa: E501
        else:
            (data) = self.monitor_delete_maintenance_period_from_monitor_with_http_info(monitor_guid, maintenance_period_id, **kwargs)  # noqa: E501
            return data

    def monitor_delete_maintenance_period_from_monitor_with_http_info(self, monitor_guid, maintenance_period_id, **kwargs):  # noqa: E501
        """Deletes the specified maintenance period from the specified monitor  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.monitor_delete_maintenance_period_from_monitor_with_http_info(monitor_guid, maintenance_period_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str monitor_guid: (required)
        :param int maintenance_period_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['monitor_guid', 'maintenance_period_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method monitor_delete_maintenance_period_from_monitor" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'monitor_guid' is set
        if ('monitor_guid' not in params or
                params['monitor_guid'] is None):
            raise ValueError("Missing the required parameter `monitor_guid` when calling `monitor_delete_maintenance_period_from_monitor`")  # noqa: E501
        # verify the required parameter 'maintenance_period_id' is set
        if ('maintenance_period_id' not in params or
                params['maintenance_period_id'] is None):
            raise ValueError("Missing the required parameter `maintenance_period_id` when calling `monitor_delete_maintenance_period_from_monitor`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'monitor_guid' in params:
            path_params['monitorGuid'] = params['monitor_guid']  # noqa: E501
        if 'maintenance_period_id' in params:
            path_params['maintenancePeriodId'] = params['maintenance_period_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicauth']  # noqa: E501

        return self.api_client.call_api(
            '/Monitor/{monitorGuid}/MaintenancePeriod/{maintenancePeriodId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def monitor_delete_monitor(self, monitor_guid, **kwargs):  # noqa: E501
        """Deletes the specified monitor.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.monitor_delete_monitor(monitor_guid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str monitor_guid: The guid of the monitor you want to delete. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.monitor_delete_monitor_with_http_info(monitor_guid, **kwargs)  # noqa: E501
        else:
            (data) = self.monitor_delete_monitor_with_http_info(monitor_guid, **kwargs)  # noqa: E501
            return data

    def monitor_delete_monitor_with_http_info(self, monitor_guid, **kwargs):  # noqa: E501
        """Deletes the specified monitor.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.monitor_delete_monitor_with_http_info(monitor_guid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str monitor_guid: The guid of the monitor you want to delete. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['monitor_guid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method monitor_delete_monitor" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'monitor_guid' is set
        if ('monitor_guid' not in params or
                params['monitor_guid'] is None):
            raise ValueError("Missing the required parameter `monitor_guid` when calling `monitor_delete_monitor`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'monitor_guid' in params:
            path_params['monitorGuid'] = params['monitor_guid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicauth']  # noqa: E501

        return self.api_client.call_api(
            '/Monitor/{monitorGuid}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def monitor_get_all_maintenance_periods_for_monitor(self, monitor_guid, **kwargs):  # noqa: E501
        """Finds all maintenance periods for a monitor.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.monitor_get_all_maintenance_periods_for_monitor(monitor_guid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str monitor_guid: The guid of the monitor you want to find the maintenance periods of. (required)
        :return: list[MaintenancePeriod]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.monitor_get_all_maintenance_periods_for_monitor_with_http_info(monitor_guid, **kwargs)  # noqa: E501
        else:
            (data) = self.monitor_get_all_maintenance_periods_for_monitor_with_http_info(monitor_guid, **kwargs)  # noqa: E501
            return data

    def monitor_get_all_maintenance_periods_for_monitor_with_http_info(self, monitor_guid, **kwargs):  # noqa: E501
        """Finds all maintenance periods for a monitor.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.monitor_get_all_maintenance_periods_for_monitor_with_http_info(monitor_guid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str monitor_guid: The guid of the monitor you want to find the maintenance periods of. (required)
        :return: list[MaintenancePeriod]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['monitor_guid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method monitor_get_all_maintenance_periods_for_monitor" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'monitor_guid' is set
        if ('monitor_guid' not in params or
                params['monitor_guid'] is None):
            raise ValueError("Missing the required parameter `monitor_guid` when calling `monitor_get_all_maintenance_periods_for_monitor`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'monitor_guid' in params:
            path_params['monitorGuid'] = params['monitor_guid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicauth']  # noqa: E501

        return self.api_client.call_api(
            '/Monitor/{monitorGuid}/MaintenancePeriod', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[MaintenancePeriod]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def monitor_get_monitor(self, monitor_guid, **kwargs):  # noqa: E501
        """Returns the definition of the specified monitor.   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.monitor_get_monitor(monitor_guid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str monitor_guid: The Guid of the requested monitor. (required)
        :param str filter: Provide the option to only retrieve the requested fields. E.g. \"Name,IsActive\".
        :return: Monitor
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.monitor_get_monitor_with_http_info(monitor_guid, **kwargs)  # noqa: E501
        else:
            (data) = self.monitor_get_monitor_with_http_info(monitor_guid, **kwargs)  # noqa: E501
            return data

    def monitor_get_monitor_with_http_info(self, monitor_guid, **kwargs):  # noqa: E501
        """Returns the definition of the specified monitor.   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.monitor_get_monitor_with_http_info(monitor_guid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str monitor_guid: The Guid of the requested monitor. (required)
        :param str filter: Provide the option to only retrieve the requested fields. E.g. \"Name,IsActive\".
        :return: Monitor
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['monitor_guid', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method monitor_get_monitor" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'monitor_guid' is set
        if ('monitor_guid' not in params or
                params['monitor_guid'] is None):
            raise ValueError("Missing the required parameter `monitor_guid` when calling `monitor_get_monitor`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'monitor_guid' in params:
            path_params['monitorGuid'] = params['monitor_guid']  # noqa: E501

        query_params = []
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicauth']  # noqa: E501

        return self.api_client.call_api(
            '/Monitor/{monitorGuid}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Monitor',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def monitor_get_monitors(self, **kwargs):  # noqa: E501
        """Returns the definition of all monitors available in the account.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.monitor_get_monitors(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str filter: Provide the option to only retrieve the requested fields. E.g. \"Name,IsActive\".
        :return: list[Monitor]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.monitor_get_monitors_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.monitor_get_monitors_with_http_info(**kwargs)  # noqa: E501
            return data

    def monitor_get_monitors_with_http_info(self, **kwargs):  # noqa: E501
        """Returns the definition of all monitors available in the account.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.monitor_get_monitors_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str filter: Provide the option to only retrieve the requested fields. E.g. \"Name,IsActive\".
        :return: list[Monitor]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method monitor_get_monitors" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicauth']  # noqa: E501

        return self.api_client.call_api(
            '/Monitor', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Monitor]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def monitor_patch_monitor(self, monitor, monitor_guid, **kwargs):  # noqa: E501
        """Partially updates the definition of the specified monitor.  # noqa: E501

        This methods accepts parts of a monitor definition. We recommend retrieving the existing definition first (using the GET method). You can then process the changes you want to make and send back these changes only using this PATCH method.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.monitor_patch_monitor(monitor, monitor_guid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Monitor monitor: The partial definition for the monitor that should be updated. (required)
        :param str monitor_guid: The Guid of the monitor that should be updated. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.monitor_patch_monitor_with_http_info(monitor, monitor_guid, **kwargs)  # noqa: E501
        else:
            (data) = self.monitor_patch_monitor_with_http_info(monitor, monitor_guid, **kwargs)  # noqa: E501
            return data

    def monitor_patch_monitor_with_http_info(self, monitor, monitor_guid, **kwargs):  # noqa: E501
        """Partially updates the definition of the specified monitor.  # noqa: E501

        This methods accepts parts of a monitor definition. We recommend retrieving the existing definition first (using the GET method). You can then process the changes you want to make and send back these changes only using this PATCH method.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.monitor_patch_monitor_with_http_info(monitor, monitor_guid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Monitor monitor: The partial definition for the monitor that should be updated. (required)
        :param str monitor_guid: The Guid of the monitor that should be updated. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['monitor', 'monitor_guid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method monitor_patch_monitor" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'monitor' is set
        if ('monitor' not in params or
                params['monitor'] is None):
            raise ValueError("Missing the required parameter `monitor` when calling `monitor_patch_monitor`")  # noqa: E501
        # verify the required parameter 'monitor_guid' is set
        if ('monitor_guid' not in params or
                params['monitor_guid'] is None):
            raise ValueError("Missing the required parameter `monitor_guid` when calling `monitor_patch_monitor`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'monitor_guid' in params:
            path_params['monitorGuid'] = params['monitor_guid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'monitor' in params:
            body_params = params['monitor']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicauth']  # noqa: E501

        return self.api_client.call_api(
            '/Monitor/{monitorGuid}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def monitor_post_monitor(self, monitor, **kwargs):  # noqa: E501
        """Creates a new monitor.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.monitor_post_monitor(monitor, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Monitor monitor: The complete definition of the monitor that should be created. (required)
        :return: Monitor
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.monitor_post_monitor_with_http_info(monitor, **kwargs)  # noqa: E501
        else:
            (data) = self.monitor_post_monitor_with_http_info(monitor, **kwargs)  # noqa: E501
            return data

    def monitor_post_monitor_with_http_info(self, monitor, **kwargs):  # noqa: E501
        """Creates a new monitor.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.monitor_post_monitor_with_http_info(monitor, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Monitor monitor: The complete definition of the monitor that should be created. (required)
        :return: Monitor
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['monitor']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method monitor_post_monitor" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'monitor' is set
        if ('monitor' not in params or
                params['monitor'] is None):
            raise ValueError("Missing the required parameter `monitor` when calling `monitor_post_monitor`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'monitor' in params:
            body_params = params['monitor']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicauth']  # noqa: E501

        return self.api_client.call_api(
            '/Monitor', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Monitor',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def monitor_put_monitor(self, monitor, monitor_guid, **kwargs):  # noqa: E501
        """Updates the definition of the specified monitor.  # noqa: E501

        This methods only accepts a complete monitor definition. We recommend retrieving the existing definition first (using the GET method). You can then process the changes you want to make and send back the updated definition using this PUT method.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.monitor_put_monitor(monitor, monitor_guid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Monitor monitor: The complete definition for the monitor that should be updated. (required)
        :param str monitor_guid: The Guid of the monitor that should be updated. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.monitor_put_monitor_with_http_info(monitor, monitor_guid, **kwargs)  # noqa: E501
        else:
            (data) = self.monitor_put_monitor_with_http_info(monitor, monitor_guid, **kwargs)  # noqa: E501
            return data

    def monitor_put_monitor_with_http_info(self, monitor, monitor_guid, **kwargs):  # noqa: E501
        """Updates the definition of the specified monitor.  # noqa: E501

        This methods only accepts a complete monitor definition. We recommend retrieving the existing definition first (using the GET method). You can then process the changes you want to make and send back the updated definition using this PUT method.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.monitor_put_monitor_with_http_info(monitor, monitor_guid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Monitor monitor: The complete definition for the monitor that should be updated. (required)
        :param str monitor_guid: The Guid of the monitor that should be updated. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['monitor', 'monitor_guid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method monitor_put_monitor" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'monitor' is set
        if ('monitor' not in params or
                params['monitor'] is None):
            raise ValueError("Missing the required parameter `monitor` when calling `monitor_put_monitor`")  # noqa: E501
        # verify the required parameter 'monitor_guid' is set
        if ('monitor_guid' not in params or
                params['monitor_guid'] is None):
            raise ValueError("Missing the required parameter `monitor_guid` when calling `monitor_put_monitor`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'monitor_guid' in params:
            path_params['monitorGuid'] = params['monitor_guid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'monitor' in params:
            body_params = params['monitor']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicauth']  # noqa: E501

        return self.api_client.call_api(
            '/Monitor/{monitorGuid}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def monitor_update_maintenance_period_for_monitor(self, monitor_guid, maintenance_period_id, maintenance_period, **kwargs):  # noqa: E501
        """Updates the specified maintenance schedule for the specified monitor  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.monitor_update_maintenance_period_for_monitor(monitor_guid, maintenance_period_id, maintenance_period, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str monitor_guid: (required)
        :param int maintenance_period_id: (required)
        :param MaintenancePeriod maintenance_period: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.monitor_update_maintenance_period_for_monitor_with_http_info(monitor_guid, maintenance_period_id, maintenance_period, **kwargs)  # noqa: E501
        else:
            (data) = self.monitor_update_maintenance_period_for_monitor_with_http_info(monitor_guid, maintenance_period_id, maintenance_period, **kwargs)  # noqa: E501
            return data

    def monitor_update_maintenance_period_for_monitor_with_http_info(self, monitor_guid, maintenance_period_id, maintenance_period, **kwargs):  # noqa: E501
        """Updates the specified maintenance schedule for the specified monitor  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.monitor_update_maintenance_period_for_monitor_with_http_info(monitor_guid, maintenance_period_id, maintenance_period, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str monitor_guid: (required)
        :param int maintenance_period_id: (required)
        :param MaintenancePeriod maintenance_period: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['monitor_guid', 'maintenance_period_id', 'maintenance_period']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method monitor_update_maintenance_period_for_monitor" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'monitor_guid' is set
        if ('monitor_guid' not in params or
                params['monitor_guid'] is None):
            raise ValueError("Missing the required parameter `monitor_guid` when calling `monitor_update_maintenance_period_for_monitor`")  # noqa: E501
        # verify the required parameter 'maintenance_period_id' is set
        if ('maintenance_period_id' not in params or
                params['maintenance_period_id'] is None):
            raise ValueError("Missing the required parameter `maintenance_period_id` when calling `monitor_update_maintenance_period_for_monitor`")  # noqa: E501
        # verify the required parameter 'maintenance_period' is set
        if ('maintenance_period' not in params or
                params['maintenance_period'] is None):
            raise ValueError("Missing the required parameter `maintenance_period` when calling `monitor_update_maintenance_period_for_monitor`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'monitor_guid' in params:
            path_params['monitorGuid'] = params['monitor_guid']  # noqa: E501
        if 'maintenance_period_id' in params:
            path_params['maintenancePeriodId'] = params['maintenance_period_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'maintenance_period' in params:
            body_params = params['maintenance_period']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicauth']  # noqa: E501

        return self.api_client.call_api(
            '/Monitor/{monitorGuid}/MaintenancePeriod/{maintenancePeriodId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
