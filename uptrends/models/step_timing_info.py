# coding: utf-8

"""
    Uptrends API v4

    This document describes Uptrends API version 4. This Swagger environment also lets you execute API methods directly.  Please note that this is not a sandbox environment: these API methods operate directly on your actual Uptrends account.  For more information, please visit https://www.uptrends.com/api.  # noqa: E501

    OpenAPI spec version: 1.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


import pprint
import re  # noqa: F401

import six


class StepTimingInfo(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """

    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'description': 'str',
        'start_utc': 'datetime',
        'end_utc': 'datetime',
        'elapsed_milliseconds': 'int',
        'delay_milliseconds': 'int',
        'sub_timing_infos': 'list[StepTimingInfo]',
        'is_valid': 'bool'
    }

    attribute_map = {
        'description': 'Description',
        'start_utc': 'StartUtc',
        'end_utc': 'EndUtc',
        'elapsed_milliseconds': 'ElapsedMilliseconds',
        'delay_milliseconds': 'DelayMilliseconds',
        'sub_timing_infos': 'SubTimingInfos',
        'is_valid': 'IsValid'
    }

    def __init__(self, description=None, start_utc=None, end_utc=None, elapsed_milliseconds=None, delay_milliseconds=None, sub_timing_infos=None, is_valid=None):  # noqa: E501
        """StepTimingInfo - a model defined in Swagger"""  # noqa: E501

        self._description = None
        self._start_utc = None
        self._end_utc = None
        self._elapsed_milliseconds = None
        self._delay_milliseconds = None
        self._sub_timing_infos = None
        self._is_valid = None
        self.discriminator = None

        if description is not None:
            self.description = description
        self.start_utc = start_utc
        self.end_utc = end_utc
        self.elapsed_milliseconds = elapsed_milliseconds
        self.delay_milliseconds = delay_milliseconds
        if sub_timing_infos is not None:
            self.sub_timing_infos = sub_timing_infos
        self.is_valid = is_valid

    @property
    def description(self):
        """Gets the description of this StepTimingInfo.  # noqa: E501


        :return: The description of this StepTimingInfo.  # noqa: E501
        :rtype: str
        """
        return self._description

    @description.setter
    def description(self, description):
        """Sets the description of this StepTimingInfo.


        :param description: The description of this StepTimingInfo.  # noqa: E501
        :type: str
        """

        self._description = description

    @property
    def start_utc(self):
        """Gets the start_utc of this StepTimingInfo.  # noqa: E501


        :return: The start_utc of this StepTimingInfo.  # noqa: E501
        :rtype: datetime
        """
        return self._start_utc

    @start_utc.setter
    def start_utc(self, start_utc):
        """Sets the start_utc of this StepTimingInfo.


        :param start_utc: The start_utc of this StepTimingInfo.  # noqa: E501
        :type: datetime
        """
        if start_utc is None:
            raise ValueError("Invalid value for `start_utc`, must not be `None`")  # noqa: E501

        self._start_utc = start_utc

    @property
    def end_utc(self):
        """Gets the end_utc of this StepTimingInfo.  # noqa: E501


        :return: The end_utc of this StepTimingInfo.  # noqa: E501
        :rtype: datetime
        """
        return self._end_utc

    @end_utc.setter
    def end_utc(self, end_utc):
        """Sets the end_utc of this StepTimingInfo.


        :param end_utc: The end_utc of this StepTimingInfo.  # noqa: E501
        :type: datetime
        """
        if end_utc is None:
            raise ValueError("Invalid value for `end_utc`, must not be `None`")  # noqa: E501

        self._end_utc = end_utc

    @property
    def elapsed_milliseconds(self):
        """Gets the elapsed_milliseconds of this StepTimingInfo.  # noqa: E501


        :return: The elapsed_milliseconds of this StepTimingInfo.  # noqa: E501
        :rtype: int
        """
        return self._elapsed_milliseconds

    @elapsed_milliseconds.setter
    def elapsed_milliseconds(self, elapsed_milliseconds):
        """Sets the elapsed_milliseconds of this StepTimingInfo.


        :param elapsed_milliseconds: The elapsed_milliseconds of this StepTimingInfo.  # noqa: E501
        :type: int
        """
        if elapsed_milliseconds is None:
            raise ValueError("Invalid value for `elapsed_milliseconds`, must not be `None`")  # noqa: E501

        self._elapsed_milliseconds = elapsed_milliseconds

    @property
    def delay_milliseconds(self):
        """Gets the delay_milliseconds of this StepTimingInfo.  # noqa: E501


        :return: The delay_milliseconds of this StepTimingInfo.  # noqa: E501
        :rtype: int
        """
        return self._delay_milliseconds

    @delay_milliseconds.setter
    def delay_milliseconds(self, delay_milliseconds):
        """Sets the delay_milliseconds of this StepTimingInfo.


        :param delay_milliseconds: The delay_milliseconds of this StepTimingInfo.  # noqa: E501
        :type: int
        """
        if delay_milliseconds is None:
            raise ValueError("Invalid value for `delay_milliseconds`, must not be `None`")  # noqa: E501

        self._delay_milliseconds = delay_milliseconds

    @property
    def sub_timing_infos(self):
        """Gets the sub_timing_infos of this StepTimingInfo.  # noqa: E501


        :return: The sub_timing_infos of this StepTimingInfo.  # noqa: E501
        :rtype: list[StepTimingInfo]
        """
        return self._sub_timing_infos

    @sub_timing_infos.setter
    def sub_timing_infos(self, sub_timing_infos):
        """Sets the sub_timing_infos of this StepTimingInfo.


        :param sub_timing_infos: The sub_timing_infos of this StepTimingInfo.  # noqa: E501
        :type: list[StepTimingInfo]
        """

        self._sub_timing_infos = sub_timing_infos

    @property
    def is_valid(self):
        """Gets the is_valid of this StepTimingInfo.  # noqa: E501

        If true, this TimingInfo should be counted as part of the sum of its siblings. If false, the TimingInfo should be discarded (e.g. for PreDelays we don't want to count).  # noqa: E501

        :return: The is_valid of this StepTimingInfo.  # noqa: E501
        :rtype: bool
        """
        return self._is_valid

    @is_valid.setter
    def is_valid(self, is_valid):
        """Sets the is_valid of this StepTimingInfo.

        If true, this TimingInfo should be counted as part of the sum of its siblings. If false, the TimingInfo should be discarded (e.g. for PreDelays we don't want to count).  # noqa: E501

        :param is_valid: The is_valid of this StepTimingInfo.  # noqa: E501
        :type: bool
        """
        if is_valid is None:
            raise ValueError("Invalid value for `is_valid`, must not be `None`")  # noqa: E501

        self._is_valid = is_valid

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(StepTimingInfo, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, StepTimingInfo):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
